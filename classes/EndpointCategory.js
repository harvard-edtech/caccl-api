/**
 * Class that handles a category of endpoints
 * @module classes/EndpointCategory
 * @see module: classes/EndpointCategory
 */

// Endpoint-related helpers
const genEndpointFunction = require('./endpoint/genEndpointFunction.js');

/** A category of endpoints */
class EndpointCategory {
  /**
   * Creates an EndpointCategory
   * @param {number} config.visitEndpoint - An instance of a visitEndpoint
   *   function generated by classes/endpoint/genEndpointFunction
   * @param {object} [api=this] - Top level instance of endpoints/Endpoints.js
   *   that this EndpointCategory instance is an ancestor of
   * @param {object} [config.cache=null] - A cache instance to use. If excluded,
   *   caching is turned off
   */
  constructor(config, Child) {
    // Add api if it's not included
    const newConfig = config;
    if (!newConfig.api) {
      newConfig.api = this;
    }

    // Create an uncache function to pass to endpoints
    let uncache;
    if (newConfig.cache) {
      // Create uncache function that changes the cache
      uncache = (paths, response) => {
        return newConfig.cache.getAllPaths().then((cachedPaths) => {
          // Find paths that need to be uncached
          const pathsToUncache = [];
          paths.forEach((path) => {
            if (path.endsWith('*')) {
              // This is a prefix-based path. Loop to find paths that match.
              const prefix = path.split('*')[0];
              cachedPaths.forEach((cachedPath) => {
                if (cachedPath.startsWith(prefix)) {
                  // Prefix matches! Uncache this!
                  pathsToUncache.push(cachedPath);
                }
              });
            } else {
              // This is a normal path. Just add it.
              pathsToUncache.push(path);
            }
          });

          // Uncache
          return newConfig.cache.deletePaths(pathsToUncache);
        }).then(() => {
          // Finally resolve with response
          return Promise.resolve(response);
        });
      };
    } else {
      // No cache. Return dummy function that does nothing
      uncache = (_, response) => {
        return Promise.resolve(response);
      };
    }

    // Turn each endpoint (defined as a static function in the child) into a
    // function
    Object.keys(Child).forEach((prop) => {
      if (Child[prop].isEndpointCategory) {
        // This is a sub-category
        this[prop] = new Child[prop](newConfig);
      } else {
        // This is an endpoint

        // Extract action from first line of function
        let action;
        try {
          const firstLine = Child[prop].toString().split('\n')[1];
          action = firstLine.split('// @action: ')[1].trim();
        } catch (err) {
          action = 'perform an unnamed task';
        }

        // Create the function
        this[prop] = genEndpointFunction({
          uncache,
          action,
          api: newConfig.api,
          run: Child[prop],
          cache: newConfig.cache,
          visitEndpoint: newConfig.visitEndpoint,
        });
      }
    });
  }
}

// Mark EndpointCategory so we can detect it
EndpointCategory.isEndpointCategory = true;

module.exports = EndpointCategory;
